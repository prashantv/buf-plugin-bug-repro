{
  "swagger": "2.0",
  "info": {
    "title": "google/api/expr/conformance/v1alpha1/conformance_service.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "ConformanceService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "DeclFunctionDecl": {
      "type": "object",
      "properties": {
        "overloads": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/FunctionDeclOverload"
          },
          "description": "Required. List of function overloads, must contain at least one overload."
        }
      },
      "description": "Function declaration specifies one or more overloads which indicate the\nfunction's parameter types and return type.\n\nFunctions have no observable side-effects (there may be side-effects like\nlogging which are not observable from CEL)."
    },
    "DeclIdentDecl": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/exprv1alpha1Type",
          "description": "Required. The type of the identifier."
        },
        "value": {
          "$ref": "#/definitions/v1alpha1Constant",
          "description": "The constant value of the identifier. If not specified, the identifier\nmust be supplied at evaluation time."
        },
        "doc": {
          "type": "string",
          "description": "Documentation string for the identifier."
        }
      },
      "description": "Identifier declaration which specifies its type and optional `Expr` value.\n\nAn identifier without a value is a declaration that must be provided at\nevaluation time. An identifier with a value should resolve to a constant,\nbut may be used in conjunction with other identifiers bound at evaluation\ntime."
    },
    "ExprCall": {
      "type": "object",
      "properties": {
        "target": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "The target of an method call-style expression. For example, `x` in\n`x.f()`."
        },
        "function": {
          "type": "string",
          "description": "Required. The name of the function or method being called."
        },
        "args": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Expr"
          },
          "description": "The arguments."
        }
      },
      "description": "A call expression, including calls to predefined functions and operators.\n\nFor example, `value == 10`, `size(map_value)`."
    },
    "ExprComprehension": {
      "type": "object",
      "properties": {
        "iter_var": {
          "type": "string",
          "description": "The name of the iteration variable."
        },
        "iter_range": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "The range over which var iterates."
        },
        "accu_var": {
          "type": "string",
          "description": "The name of the variable used for accumulation of the result."
        },
        "accu_init": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "The initial value of the accumulator."
        },
        "loop_condition": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "An expression which can contain iter_var and accu_var.\n\nReturns false when the result has been computed and may be used as\na hint to short-circuit the remainder of the comprehension."
        },
        "loop_step": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "An expression which can contain iter_var and accu_var.\n\nComputes the next value of accu_var."
        },
        "result": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "An expression which can contain accu_var.\n\nComputes the result."
        }
      },
      "description": "A comprehension expression applied to a list or map.\n\nComprehensions are not part of the core syntax, but enabled with macros.\nA macro matches a specific call signature within a parsed AST and replaces\nthe call with an alternate AST block. Macro expansion happens at parse\ntime.\n\nThe following macros are supported within CEL:\n\nAggregate type macros may be applied to all elements in a list or all keys\nin a map:\n\n*  `all`, `exists`, `exists_one` -  test a predicate expression against\n   the inputs and return `true` if the predicate is satisfied for all,\n   any, or only one value `list.all(x, x \u003c 10)`.\n*  `filter` - test a predicate expression against the inputs and return\n   the subset of elements which satisfy the predicate:\n   `payments.filter(p, p \u003e 1000)`.\n*  `map` - apply an expression to all elements in the input and return the\n   output aggregate type: `[1, 2, 3].map(i, i * i)`.\n\nThe `has(m.x)` macro tests whether the property `x` is present in struct\n`m`. The semantics of this macro depend on the type of `m`. For proto2\nmessages `has(m.x)` is defined as 'defined, but not set`. For proto3, the\nmacro tests whether the property is set to its default. For map and struct\ntypes, the macro tests whether the property `x` is defined on `m`."
    },
    "ExprCreateList": {
      "type": "object",
      "properties": {
        "elements": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Expr"
          },
          "description": "The elements part of the list."
        },
        "optional_indices": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          },
          "description": "The indices within the elements list which are marked as optional\nelements.\n\nWhen an optional-typed value is present, the value it contains\nis included in the list. If the optional-typed value is absent, the list\nelement is omitted from the CreateList result."
        }
      },
      "description": "A list creation expression.\n\nLists may either be homogenous, e.g. `[1, 2, 3]`, or heterogeneous, e.g.\n`dyn([1, 'hello', 2.0])`"
    },
    "ExprCreateStruct": {
      "type": "object",
      "properties": {
        "message_name": {
          "type": "string",
          "description": "The type name of the message to be created, empty when creating map\nliterals."
        },
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ExprCreateStructEntry"
          },
          "description": "The entries in the creation expression."
        }
      },
      "description": "A map or message creation expression.\n\nMaps are constructed as `{'key_name': 'value'}`. Message construction is\nsimilar, but prefixed with a type name and composed of field ids:\n`types.MyType{field_id: 'value'}`."
    },
    "ExprCreateStructEntry": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "int64",
          "description": "Required. An id assigned to this node by the parser which is unique\nin a given expression tree. This is used to associate type\ninformation and other attributes to the node."
        },
        "field_key": {
          "type": "string",
          "description": "The field key for a message creator statement."
        },
        "map_key": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "The key expression for a map creation statement."
        },
        "value": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "Required. The value assigned to the key.\n\nIf the optional_entry field is true, the expression must resolve to an\noptional-typed value. If the optional value is present, the key will be\nset; however, if the optional value is absent, the key will be unset."
        },
        "optional_entry": {
          "type": "boolean",
          "description": "Whether the key-value pair is optional."
        }
      },
      "description": "Represents an entry."
    },
    "ExprIdent": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Required. Holds a single, unqualified identifier, possibly preceded by a\n'.'.\n\nQualified names are represented by the\n[Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression."
        }
      },
      "description": "An identifier expression. e.g. `request`."
    },
    "ExprSelect": {
      "type": "object",
      "properties": {
        "operand": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "Required. The target of the selection expression.\n\nFor example, in the select expression `request.auth`, the `request`\nportion of the expression is the `operand`."
        },
        "field": {
          "type": "string",
          "description": "Required. The name of the field to select.\n\nFor example, in the select expression `request.auth`, the `auth` portion\nof the expression would be the `field`."
        },
        "test_only": {
          "type": "boolean",
          "description": "Whether the select is to be interpreted as a field presence test.\n\nThis results from the macro `has(request.auth)`."
        }
      },
      "description": "A field selection expression. e.g. `request.auth`."
    },
    "ExtensionComponent": {
      "type": "string",
      "enum": [
        "COMPONENT_PARSER",
        "COMPONENT_TYPE_CHECKER",
        "COMPONENT_RUNTIME"
      ],
      "description": "CEL component specifier.\n\n - COMPONENT_PARSER: Parser. Converts a CEL string to an AST.\n - COMPONENT_TYPE_CHECKER: Type checker. Checks that references in an AST are defined and types\nagree.\n - COMPONENT_RUNTIME: Runtime. Evaluates a parsed and optionally checked CEL AST against a\ncontext."
    },
    "ExtensionVersion": {
      "type": "object",
      "properties": {
        "major": {
          "type": "string",
          "format": "int64",
          "description": "Major version changes indicate different required support level from\nthe required components."
        },
        "minor": {
          "type": "string",
          "format": "int64",
          "description": "Minor version changes must not change the observed behavior from\nexisting implementations, but may be provided informationally."
        }
      },
      "title": "Version"
    },
    "FunctionDeclOverload": {
      "type": "object",
      "properties": {
        "overload_id": {
          "type": "string",
          "description": "Required. Globally unique overload name of the function which reflects\nthe function name and argument types.\n\nThis will be used by a [Reference][google.api.expr.v1alpha1.Reference]\nto indicate the `overload_id` that was resolved for the function\n`name`."
        },
        "params": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/exprv1alpha1Type"
          },
          "description": "List of function parameter [Type][google.api.expr.v1alpha1.Type]\nvalues.\n\nParam types are disjoint after generic type parameters have been\nreplaced with the type `DYN`. Since the `DYN` type is compatible with\nany other type, this means that if `A` is a type parameter, the\nfunction types `int\u003cA\u003e` and `int\u003cint\u003e` are not disjoint. Likewise,\n`map\u003cstring, string\u003e` is not disjoint from `map\u003cK, V\u003e`.\n\nWhen the `result_type` of a function is a generic type param, the\ntype param name also appears as the `type` of on at least one params."
        },
        "type_params": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The type param names associated with the function declaration.\n\nFor example, `function ex\u003cK,V\u003e(K key, map\u003cK, V\u003e map) : V` would yield\nthe type params of `K, V`."
        },
        "result_type": {
          "$ref": "#/definitions/exprv1alpha1Type",
          "description": "Required. The result type of the function. For example, the operator\n`string.isEmpty()` would have `result_type` of `kind: BOOL`."
        },
        "is_instance_function": {
          "type": "boolean",
          "description": "Whether the function is to be used in a method call-style `x.f(...)`\nor a function call-style `f(x, ...)`.\n\nFor methods, the first parameter declaration, `params[0]` is the\nexpected type of the target receiver."
        },
        "doc": {
          "type": "string",
          "description": "Documentation string for the overload."
        }
      },
      "description": "An overload indicates a function's parameter types and return type, and\nmay optionally include a function body described in terms of\n[Expr][google.api.expr.v1alpha1.Expr] values.\n\nFunctions overloads are declared in either a function or method\ncall-style. For methods, the `params[0]` is the expected type of the\ntarget receiver.\n\nOverloads must have non-overlapping argument types after erasure of all\nparameterized type variables (similar as type erasure in Java)."
    },
    "SourceInfoExtension": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "title": "Identifier for the extension. Example: constant_folding"
        },
        "affected_components": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ExtensionComponent"
          },
          "description": "If set, the listed components must understand the extension for the\nexpression to evaluate correctly.\n\nThis field has set semantics, repeated values should be deduplicated."
        },
        "version": {
          "$ref": "#/definitions/ExtensionVersion",
          "description": "Version info. May be skipped if it isn't meaningful for the extension.\n(for example constant_folding might always be v0.0)."
        }
      },
      "description": "An extension that was requested for the source expression."
    },
    "TypeAbstractType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The fully qualified name of this abstract type."
        },
        "parameter_types": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/exprv1alpha1Type"
          },
          "description": "Parameter types for this abstract type."
        }
      },
      "description": "Application defined abstract type."
    },
    "TypeFunctionType": {
      "type": "object",
      "properties": {
        "result_type": {
          "$ref": "#/definitions/exprv1alpha1Type",
          "description": "Result type of the function."
        },
        "arg_types": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/exprv1alpha1Type"
          },
          "description": "Argument types of the function."
        }
      },
      "description": "Function type with result and arg types."
    },
    "TypeListType": {
      "type": "object",
      "properties": {
        "elem_type": {
          "$ref": "#/definitions/exprv1alpha1Type",
          "description": "The element type."
        }
      },
      "description": "List type with typed elements, e.g. `list\u003cexample.proto.MyMessage\u003e`."
    },
    "TypeMapType": {
      "type": "object",
      "properties": {
        "key_type": {
          "$ref": "#/definitions/exprv1alpha1Type",
          "description": "The type of the key."
        },
        "value_type": {
          "$ref": "#/definitions/exprv1alpha1Type",
          "description": "The type of the value."
        }
      },
      "description": "Map type with parameterized key and value types, e.g. `map\u003cstring, int\u003e`."
    },
    "TypePrimitiveType": {
      "type": "string",
      "enum": [
        "BOOL",
        "INT64",
        "UINT64",
        "DOUBLE",
        "STRING",
        "BYTES"
      ],
      "description": "CEL primitive types.\n\n - BOOL: Boolean type.\n - INT64: Int64 type.\n\nProto-based integer values are widened to int64.\n - UINT64: Uint64 type.\n\nProto-based unsigned integer values are widened to uint64.\n - DOUBLE: Double type.\n\nProto-based float values are widened to double values.\n - STRING: String type.\n - BYTES: Bytes type."
    },
    "TypeWellKnownType": {
      "type": "string",
      "enum": [
        "ANY",
        "TIMESTAMP",
        "DURATION"
      ],
      "description": "Well-known protobuf types treated with first-class support in CEL.\n\n - ANY: Well-known protobuf.Any type.\n\nAny types are a polymorphic message type. During type-checking they are\ntreated like `DYN` types, but at runtime they are resolved to a specific\nmessage type specified at evaluation time.\n - TIMESTAMP: Well-known protobuf.Timestamp type, internally referenced as `timestamp`.\n - DURATION: Well-known protobuf.Duration type, internally referenced as `duration`."
    },
    "exprv1alpha1ListValue": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/exprv1alpha1Value"
          },
          "description": "The ordered values in the list."
        }
      },
      "description": "A list.\n\nWrapped in a message so 'not set' and empty can be differentiated, which is\nrequired for use in a 'oneof'."
    },
    "exprv1alpha1Type": {
      "type": "object",
      "properties": {
        "dyn": {
          "type": "object",
          "properties": {},
          "description": "Dynamic type."
        },
        "null": {
          "type": "string",
          "description": "Null value."
        },
        "primitive": {
          "$ref": "#/definitions/TypePrimitiveType",
          "description": "Primitive types: `true`, `1u`, `-2.0`, `'string'`, `b'bytes'`."
        },
        "wrapper": {
          "$ref": "#/definitions/TypePrimitiveType",
          "description": "Wrapper of a primitive type, e.g. `google.protobuf.Int64Value`."
        },
        "well_known": {
          "$ref": "#/definitions/TypeWellKnownType",
          "description": "Well-known protobuf type such as `google.protobuf.Timestamp`."
        },
        "list_type": {
          "$ref": "#/definitions/TypeListType",
          "description": "Parameterized list with elements of `list_type`, e.g. `list\u003ctimestamp\u003e`."
        },
        "map_type": {
          "$ref": "#/definitions/TypeMapType",
          "description": "Parameterized map with typed keys and values."
        },
        "function": {
          "$ref": "#/definitions/TypeFunctionType",
          "description": "Function type."
        },
        "message_type": {
          "type": "string",
          "description": "Protocol buffer message type.\n\nThe `message_type` string specifies the qualified message type name. For\nexample, `google.plus.Profile`."
        },
        "type_param": {
          "type": "string",
          "description": "Type param type.\n\nThe `type_param` string specifies the type parameter name, e.g. `list\u003cE\u003e`\nwould be a `list_type` whose element type was a `type_param` type\nnamed `E`."
        },
        "type": {
          "$ref": "#/definitions/exprv1alpha1Type",
          "description": "Type type.\n\nThe `type` value specifies the target type. e.g. int is type with a\ntarget type of `Primitive.INT`."
        },
        "error": {
          "type": "object",
          "properties": {},
          "description": "Error type.\n\nDuring type-checking if an expression is an error, its type is propagated\nas the `ERROR` type. This permits the type-checker to discover other\nerrors present in the expression."
        },
        "abstract_type": {
          "$ref": "#/definitions/TypeAbstractType",
          "description": "Abstract, application defined type."
        }
      },
      "description": "Represents a CEL type."
    },
    "exprv1alpha1Value": {
      "type": "object",
      "properties": {
        "null_value": {
          "type": "string",
          "description": "Null value."
        },
        "bool_value": {
          "type": "boolean",
          "description": "Boolean value."
        },
        "int64_value": {
          "type": "string",
          "format": "int64",
          "description": "Signed integer value."
        },
        "uint64_value": {
          "type": "string",
          "format": "uint64",
          "description": "Unsigned integer value."
        },
        "double_value": {
          "type": "number",
          "format": "double",
          "description": "Floating point value."
        },
        "string_value": {
          "type": "string",
          "description": "UTF-8 string value."
        },
        "bytes_value": {
          "type": "string",
          "format": "byte",
          "description": "Byte string value."
        },
        "enum_value": {
          "$ref": "#/definitions/v1alpha1EnumValue",
          "description": "An enum value."
        },
        "object_value": {
          "$ref": "#/definitions/protobufAny",
          "description": "The proto message backing an object value."
        },
        "map_value": {
          "$ref": "#/definitions/v1alpha1MapValue",
          "description": "Map value."
        },
        "list_value": {
          "$ref": "#/definitions/exprv1alpha1ListValue",
          "description": "List value."
        },
        "type_value": {
          "type": "string",
          "description": "Type value."
        }
      },
      "description": "Represents a CEL value.\n\nThis is similar to `google.protobuf.Value`, but can represent CEL's full\nrange of values."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protobufNullValue": {
      "type": "string",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`."
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "The status code, which should be an enum value of\n[google.rpc.Code][google.rpc.Code]."
        },
        "message": {
          "type": "string",
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\n[google.rpc.Status.details][google.rpc.Status.details] field, or localized\nby the client."
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          },
          "description": "A list of messages that carry the error details.  There is a common set of\nmessage types for APIs to use."
        }
      },
      "description": "The `Status` type defines a logical error model that is suitable for\ndifferent programming environments, including REST APIs and RPC APIs. It is\nused by [gRPC](https://github.com/grpc). Each `Status` message contains\nthree pieces of data: error code, error message, and error details.\n\nYou can find out more about this error model and how to work with it in the\n[API Design Guide](https://cloud.google.com/apis/design/errors)."
    },
    "v1alpha1CheckResponse": {
      "type": "object",
      "properties": {
        "checked_expr": {
          "$ref": "#/definitions/v1alpha1CheckedExpr",
          "description": "The annotated representation, or unset if checking failed."
        },
        "issues": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/rpcStatus"
          },
          "description": "Any number of issues with [StatusDetails][] as the details."
        }
      },
      "description": "Response message for the Check method."
    },
    "v1alpha1CheckedExpr": {
      "type": "object",
      "properties": {
        "reference_map": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1alpha1Reference"
          },
          "description": "A map from expression ids to resolved references.\n\nThe following entries are in this table:\n\n- An Ident or Select expression is represented here if it resolves to a\n  declaration. For instance, if `a.b.c` is represented by\n  `select(select(id(a), b), c)`, and `a.b` resolves to a declaration,\n  while `c` is a field selection, then the reference is attached to the\n  nested select expression (but not to the id or or the outer select).\n  In turn, if `a` resolves to a declaration and `b.c` are field selections,\n  the reference is attached to the ident expression.\n- Every Call expression has an entry here, identifying the function being\n  called.\n- Every CreateStruct expression for a message has an entry, identifying\n  the message."
        },
        "type_map": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/exprv1alpha1Type"
          },
          "description": "A map from expression ids to types.\n\nEvery expression node which has a type different than DYN has a mapping\nhere. If an expression has type DYN, it is omitted from this map to save\nspace."
        },
        "source_info": {
          "$ref": "#/definitions/v1alpha1SourceInfo",
          "description": "The source info derived from input that generated the parsed `expr` and\nany optimizations made during the type-checking pass."
        },
        "expr_version": {
          "type": "string",
          "description": "The expr version indicates the major / minor version number of the `expr`\nrepresentation.\n\nThe most common reason for a version change will be to indicate to the CEL\nruntimes that transformations have been performed on the expr during static\nanalysis. In some cases, this will save the runtime the work of applying\nthe same or similar transformations prior to evaluation."
        },
        "expr": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "The checked expression. Semantically equivalent to the parsed `expr`, but\nmay have structural differences."
        }
      },
      "description": "A CEL expression which has been successfully type checked."
    },
    "v1alpha1Constant": {
      "type": "object",
      "properties": {
        "null_value": {
          "type": "string",
          "description": "null value."
        },
        "bool_value": {
          "type": "boolean",
          "description": "boolean value."
        },
        "int64_value": {
          "type": "string",
          "format": "int64",
          "description": "int64 value."
        },
        "uint64_value": {
          "type": "string",
          "format": "uint64",
          "description": "uint64 value."
        },
        "double_value": {
          "type": "number",
          "format": "double",
          "description": "double value."
        },
        "string_value": {
          "type": "string",
          "description": "string value."
        },
        "bytes_value": {
          "type": "string",
          "format": "byte",
          "description": "bytes value."
        },
        "duration_value": {
          "type": "string",
          "description": "protobuf.Duration value.\n\nDeprecated: duration is no longer considered a builtin cel type."
        },
        "timestamp_value": {
          "type": "string",
          "format": "date-time",
          "description": "protobuf.Timestamp value.\n\nDeprecated: timestamp is no longer considered a builtin cel type."
        }
      },
      "description": "Represents a primitive literal.\n\nNamed 'Constant' here for backwards compatibility.\n\nThis is similar as the primitives supported in the well-known type\n`google.protobuf.Value`, but richer so it can represent CEL's full range of\nprimitives.\n\nLists and structs are not included as constants as these aggregate types may\ncontain [Expr][google.api.expr.v1alpha1.Expr] elements which require\nevaluation and are thus not constant.\n\nExamples of literals include: `\"hello\"`, `b'bytes'`, `1u`, `4.2`, `-2`,\n`true`, `null`."
    },
    "v1alpha1Decl": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The fully qualified name of the declaration.\n\nDeclarations are organized in containers and this represents the full path\nto the declaration in its container, as in `google.api.expr.Decl`.\n\nDeclarations used as\n[FunctionDecl.Overload][google.api.expr.v1alpha1.Decl.FunctionDecl.Overload]\nparameters may or may not have a name depending on whether the overload is\nfunction declaration or a function definition containing a result\n[Expr][google.api.expr.v1alpha1.Expr]."
        },
        "ident": {
          "$ref": "#/definitions/DeclIdentDecl",
          "description": "Identifier declaration."
        },
        "function": {
          "$ref": "#/definitions/DeclFunctionDecl",
          "description": "Function declaration."
        }
      },
      "description": "Represents a declaration of a named value or function.\n\nA declaration is part of the contract between the expression, the agent\nevaluating that expression, and the caller requesting evaluation."
    },
    "v1alpha1EnumValue": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "The fully qualified name of the enum type."
        },
        "value": {
          "type": "integer",
          "format": "int32",
          "description": "The value of the enum."
        }
      },
      "description": "An enum value."
    },
    "v1alpha1ErrorSet": {
      "type": "object",
      "properties": {
        "errors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/rpcStatus"
          },
          "description": "The errors in the set."
        }
      },
      "description": "A set of errors.\n\nThe errors included depend on the context. See `ExprValue.error`."
    },
    "v1alpha1EvalResponse": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1alpha1ExprValue",
          "description": "The execution result, or unset if execution couldn't start."
        },
        "issues": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/rpcStatus"
          },
          "description": "Any number of issues with [StatusDetails][] as the details.\nNote that CEL execution errors are reified into [ExprValue][].\nNevertheless, we'll allow out-of-band issues to be raised,\nwhich also makes the replies more regular."
        }
      },
      "description": "Response message for the Eval method."
    },
    "v1alpha1Expr": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "int64",
          "description": "Required. An id assigned to this node by the parser which is unique in a\ngiven expression tree. This is used to associate type information and other\nattributes to a node in the parse tree."
        },
        "const_expr": {
          "$ref": "#/definitions/v1alpha1Constant",
          "description": "A literal expression."
        },
        "ident_expr": {
          "$ref": "#/definitions/ExprIdent",
          "description": "An identifier expression."
        },
        "select_expr": {
          "$ref": "#/definitions/ExprSelect",
          "description": "A field selection expression, e.g. `request.auth`."
        },
        "call_expr": {
          "$ref": "#/definitions/ExprCall",
          "description": "A call expression, including calls to predefined functions and operators."
        },
        "list_expr": {
          "$ref": "#/definitions/ExprCreateList",
          "description": "A list creation expression."
        },
        "struct_expr": {
          "$ref": "#/definitions/ExprCreateStruct",
          "description": "A map or message creation expression."
        },
        "comprehension_expr": {
          "$ref": "#/definitions/ExprComprehension",
          "description": "A comprehension expression."
        }
      },
      "description": "An abstract representation of a common expression.\n\nExpressions are abstractly represented as a collection of identifiers,\nselect statements, function calls, literals, and comprehensions. All\noperators with the exception of the '.' operator are modelled as function\ncalls. This makes it easy to represent new operators into the existing AST.\n\nAll references within expressions must resolve to a\n[Decl][google.api.expr.v1alpha1.Decl] provided at type-check for an\nexpression to be valid. A reference may either be a bare identifier `name` or\na qualified identifier `google.api.name`. References may either refer to a\nvalue or a function declaration.\n\nFor example, the expression `google.api.name.startsWith('expr')` references\nthe declaration `google.api.name` within a\n[Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and the\nfunction declaration `startsWith`."
    },
    "v1alpha1ExprValue": {
      "type": "object",
      "properties": {
        "value": {
          "$ref": "#/definitions/exprv1alpha1Value",
          "description": "A concrete value."
        },
        "error": {
          "$ref": "#/definitions/v1alpha1ErrorSet",
          "description": "The set of errors in the critical path of evalution.\n\nOnly errors in the critical path are included. For example,\n`(\u003cerror1\u003e || true) \u0026\u0026 \u003cerror2\u003e` will only result in `\u003cerror2\u003e`,\nwhile `\u003cerror1\u003e || \u003cerror2\u003e` will result in both `\u003cerror1\u003e` and\n`\u003cerror2\u003e`.\n\nErrors cause by the presence of other errors are not included in the\nset. For example `\u003cerror1\u003e.foo`, `foo(\u003cerror1\u003e)`, and `\u003cerror1\u003e + 1` will\nonly result in `\u003cerror1\u003e`.\n\nMultiple errors *might* be included when evaluation could result\nin different errors. For example `\u003cerror1\u003e + \u003cerror2\u003e` and\n`foo(\u003cerror1\u003e, \u003cerror2\u003e)` may result in `\u003cerror1\u003e`, `\u003cerror2\u003e` or both.\nThe exact subset of errors included for this case is unspecified and\ndepends on the implementation details of the evaluator."
        },
        "unknown": {
          "$ref": "#/definitions/v1alpha1UnknownSet",
          "description": "The set of unknowns in the critical path of evaluation.\n\nUnknown behaves identically to Error with regards to propagation.\nSpecifically, only unknowns in the critical path are included, unknowns\ncaused by the presence of other unknowns are not included, and multiple\nunknowns *might* be included included when evaluation could result in\ndifferent unknowns. For example:\n\n    (\u003cunknown[1]\u003e || true) \u0026\u0026 \u003cunknown[2]\u003e -\u003e \u003cunknown[2]\u003e\n    \u003cunknown[1]\u003e || \u003cunknown[2]\u003e -\u003e \u003cunknown[1,2]\u003e\n    \u003cunknown[1]\u003e.foo -\u003e \u003cunknown[1]\u003e\n    foo(\u003cunknown[1]\u003e) -\u003e \u003cunknown[1]\u003e\n    \u003cunknown[1]\u003e + \u003cunknown[2]\u003e -\u003e \u003cunknown[1]\u003e or \u003cunknown[2[\u003e\n\nUnknown takes precidence over Error in cases where a `Value` can short\ncircuit the result:\n\n    \u003cerror\u003e || \u003cunknown\u003e -\u003e \u003cunknown\u003e\n    \u003cerror\u003e \u0026\u0026 \u003cunknown\u003e -\u003e \u003cunknown\u003e\n\nErrors take precidence in all other cases:\n\n    \u003cunknown\u003e + \u003cerror\u003e -\u003e \u003cerror\u003e\n    foo(\u003cunknown\u003e, \u003cerror\u003e) -\u003e \u003cerror\u003e"
        }
      },
      "description": "The value of an evaluated expression."
    },
    "v1alpha1MapValue": {
      "type": "object",
      "properties": {
        "entries": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1MapValueEntry"
          },
          "description": "The set of map entries.\n\nCEL has fewer restrictions on keys, so a protobuf map represenation\ncannot be used."
        }
      },
      "description": "A map.\n\nWrapped in a message so 'not set' and empty can be differentiated, which is\nrequired for use in a 'oneof'."
    },
    "v1alpha1MapValueEntry": {
      "type": "object",
      "properties": {
        "key": {
          "$ref": "#/definitions/exprv1alpha1Value",
          "description": "The key.\n\nMust be unique with in the map.\nCurrently only boolean, int, uint, and string values can be keys."
        },
        "value": {
          "$ref": "#/definitions/exprv1alpha1Value",
          "description": "The value."
        }
      },
      "description": "An entry in the map."
    },
    "v1alpha1ParseResponse": {
      "type": "object",
      "properties": {
        "parsed_expr": {
          "$ref": "#/definitions/v1alpha1ParsedExpr",
          "description": "The parsed representation, or unset if parsing failed."
        },
        "issues": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/rpcStatus"
          },
          "description": "Any number of issues with [StatusDetails][] as the details."
        }
      },
      "description": "Response message for the Parse method."
    },
    "v1alpha1ParsedExpr": {
      "type": "object",
      "properties": {
        "expr": {
          "$ref": "#/definitions/v1alpha1Expr",
          "description": "The parsed expression."
        },
        "source_info": {
          "$ref": "#/definitions/v1alpha1SourceInfo",
          "description": "The source info derived from input that generated the parsed `expr`."
        }
      },
      "description": "An expression together with source information as returned by the parser."
    },
    "v1alpha1Reference": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The fully qualified name of the declaration."
        },
        "overload_id": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "For references to functions, this is a list of `Overload.overload_id`\nvalues which match according to typing rules.\n\nIf the list has more than one element, overload resolution among the\npresented candidates must happen at runtime because of dynamic types. The\ntype checker attempts to narrow down this list as much as possible.\n\nEmpty if this is not a reference to a\n[Decl.FunctionDecl][google.api.expr.v1alpha1.Decl.FunctionDecl]."
        },
        "value": {
          "$ref": "#/definitions/v1alpha1Constant",
          "description": "For references to constants, this may contain the value of the\nconstant if known at compile time."
        }
      },
      "description": "Describes a resolved reference to a declaration."
    },
    "v1alpha1SourceInfo": {
      "type": "object",
      "properties": {
        "syntax_version": {
          "type": "string",
          "description": "The syntax version of the source, e.g. `cel1`."
        },
        "location": {
          "type": "string",
          "description": "The location name. All position information attached to an expression is\nrelative to this location.\n\nThe location could be a file, UI element, or similar. For example,\n`acme/app/AnvilPolicy.cel`."
        },
        "line_offsets": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          },
          "description": "Monotonically increasing list of code point offsets where newlines\n`\\n` appear.\n\nThe line number of a given position is the index `i` where for a given\n`id` the `line_offsets[i] \u003c id_positions[id] \u003c line_offsets[i+1]`. The\ncolumn may be derivd from `id_positions[id] - line_offsets[i]`."
        },
        "positions": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int32"
          },
          "description": "A map from the parse node id (e.g. `Expr.id`) to the code point offset\nwithin the source."
        },
        "macro_calls": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1alpha1Expr"
          },
          "description": "A map from the parse node id where a macro replacement was made to the\ncall `Expr` that resulted in a macro expansion.\n\nFor example, `has(value.field)` is a function call that is replaced by a\n`test_only` field selection in the AST. Likewise, the call\n`list.exists(e, e \u003e 10)` translates to a comprehension expression. The key\nin the map corresponds to the expression id of the expanded macro, and the\nvalue is the call `Expr` that was replaced."
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/SourceInfoExtension"
          },
          "description": "A list of tags for extensions that were used while parsing or type checking\nthe source expression. For example, optimizations that require special\nruntime support may be specified.\n\nThese are used to check feature support between components in separate\nimplementations. This can be used to either skip redundant work or\nreport an error if the extension is unsupported."
        }
      },
      "description": "Source information collected at parse time."
    },
    "v1alpha1UnknownSet": {
      "type": "object",
      "properties": {
        "exprs": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          },
          "description": "The ids of the expressions with unknown values."
        }
      },
      "description": "A set of expressions for which the value is unknown.\n\nThe unknowns included depend on the context. See `ExprValue.unknown`."
    }
  }
}
